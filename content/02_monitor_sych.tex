
\section{Monitor Synchronisation}
\subsection{Java Synchronized Methoden}
\begin{lstlisting}
synchronized void f() { /* ... */ } // Object Lock
static synchronized void g() { /* ... */ } // Class Lock
\end{lstlisting}

\subsection{Monitor}
Objekt mit internem gegenseitigem Ausschluss. Nur 1 Thread operiert im Monitor. Alle äusseren Methoden synchronized.
\textbf{Wait \& Signal Mechanismus:} Threads können im Monitor auf Bedingung warten und wartende aufwecken (signal).

\begin{lstlisting}
public synchronized void withdraw(int a) {
    while (amout > balance) { wait(); }
    balance -= a;
}
public synchronized void deposit(int a) {
    balance+= amount; notifyAll();
}
\end{lstlisting}
\textbf{notify():} Bei Uniform Waiters \& One-In-One-Out Bedingungen.
\textbf{notifyAll():} Bei mehreren Bedingungen / One-In-Multiple-Out. 
\textbf{Pauschales wait \& signal:} Wartende müssen selber schauen, ob sie ein Signal interessiert.
\textbf{Signal and Continue:} Signalisierender Thread behält Monitor nach notify. Aufgeweckter Thread muss um Monitor-Eintritt kämpfen.