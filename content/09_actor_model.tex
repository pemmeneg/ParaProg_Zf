\section{Actor Model}
\textbf{Async:} nicht Blockierend.\\
Substantiell anderes Programmierkonzept.
\textbf{Aktive Objekte:} haben nebenläufiges Innenleben.
\textbf{Kommunikation:} Objekte senden und empfangen Nachrichten.
\textbf{Kein Shared Memory:} Nur Austausch von Nachrichten.

\subsection{Vorteile: Actor, CSP} 
\textbf{Inhäerente Nebenläufigkeit:} Alle Obj (Actors) laufen nebenläufig.
Maschine kann Grad an Nebenläufigkeit ausnutzen.
\textbf{Keine Race Conditions:} Kein Shared Memory. Nachrichtenaustausch synchronisiert implizit.
\textbf{Gute Verteilbarkeit:} Kein Shared Memory. 
Nachrichtenaustausch für Netz prädestiniert.

\subsection{Akka}
Actor Model für JVM. Actors haben privaten Zustand, kann aber auf JVM nicht enforced werden.
Eine Mailbox pro Actor: Ein Buffer für alle ankommenden Nachrichten. Asynchones Senden.\\ 
\textbf{Empfangsverhalten:} Reaktion auf ankommende Nachricht. Behandlungsmethode wird ausgeführt.
Effekte per Behandlung (Ändere Zustand, Sende Nachrichten, Erzeuge neue Actors).
Intern sequentiell, nur eine Nachricht auf einmal behandelbar.
\begin{lstlisting}
public class Printer extends UntypedActor {
    public void onReceive(final Object message) {
        if(message instanceof Integer) { } } }
// Erzeugen und Senden
ActorSystem system = ActorSystem.create("System");
ActorRef p = system.actorOf(Props.create(Printer.class));
for(int i = 0; i < 100; i++) {
    printer.tell(i, ActorRef.noSender()); // simple async
}
System.shutdown();
\end{lstlisting}

\textbf{Anwendung:}
Alternative zu Threads, Transaction-Processing, 
Backend für Service, Kommunikations-Hub.\\ 
\textbf{Actor Hierarchies:}
Passend zu URL Adressierungsschema. Erzeuger ist Parent. 
\textit{ActorSelection} selektiert Teilbaum, broadcast möglich.
